---
title: "Cell count modelling"
author: "RJB"
date: "2025-07-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/share/lab_crd/lab_crd/HighPloidy_CostBenefits/data/GlucoseStarvation/")
```

There are a bunch of MCF10A images which don't seem to have produced valid object results. There appears to be nothing wrong with the images, so we'll need to investigate this issue further... for now filter them out for the analysis.
```{r}
source("scripts/define_plate_maps.R")
library(ggplot2)
x <- data.table::fread("data/counts/batch_results.csv")
x <- x[, time := substr(image_key, nchar(image_key) - 8, nchar(image_key) )]
x <- x[, base_key := substr(image_key, 1, nchar(image_key) - 10)]
x <- split(x,f=x$base_key)

meta <- do.call(rbind,lapply(paste0(names(x),"_00d00h00m"),get_meta))

meta <- data.table(meta)

# add a base_key column so meta and x line up
meta[, base_key := names(x)]

# build a grouping key
meta[, grp := paste(cellLine, experiment, plateID, ploidy, glucose, sep="|")]

# split the base_keys by grp
groups <- split(meta$base_key, meta$grp)

# for each group, rbindlist the corresponding xâ€™s
x_merged <- lapply(groups, function(bk) 
  rbindlist(x[bk], use.names=TRUE, fill=TRUE)
)

names(x_merged) <- names(groups)


```


```{r}
smm <- do.call(rbind,lapply(names(x_merged), function(grp) {
  dtg <- x_merged[[grp]]
  # count per well & time string
  cnt <- dtg[, .(
    alive = sum(predicted_label_name=="alive", na.rm=TRUE),
    dead  = sum(predicted_label_name=="dead",  na.rm=TRUE)
  ), by=.(time)]
  m <- str_match(cnt$time, "(\\d{2})d(\\d{2})h")
  cnt[, hours := as.integer(m[,2])*24 + as.integer(m[,3])]
  flds <- str_split(grp, "\\|")[[1]]
  cnt[, c("cellLine","experiment","plateID","ploidy","glucose") := 
        list(flds[1],flds[2],flds[3],flds[4],flds[5])]
  cnt}))

saveRDS(smm,"data/counts/uncorrected.Rds")

plots <- lapply(unique(smm$cellLine), function(cl) {
  d <- smm[cellLine == cl]
  ggplot(d, aes(x = hours)) +
    geom_point(aes(y = alive, color = "alive")) +
    geom_point(aes(y = dead, color = "dead")) +
    facet_grid(rows = vars(as.numeric(glucose)),
               cols = vars(ploidy),
               scales = "free") +
    ggtitle(cl, subtitle = unique(d$experiment))
})
names(plots) <- unique(smm$cellLine)

# Example: display the first plot
plots

```

Optimisation (~5 mins on 60 cores)
```{r}
library(parallel)
library(data.table)
library(stringr)
library(ggplot2)
library(Rcpp)

# 1) load your C++ and R functions
sourceCpp("src/count_smoothing.cpp")
source("src/optimize_counts.R")  # defines optimize_counts(dt, ...)

# 2) prune x_merged to only the columns needed and package each chunk with its name
slim_list <- lapply(names(x_merged), function(grp) {
  dt <- x_merged[[grp]][, .(
    image_key,
    predicted_label_name,
    prob_alive,
    prob_dead,
    prob_junk
  )]
  list(grp = grp, dt = dt)
})

# 3) start cluster and load dependencies on each worker
cl <- makeCluster(60)
clusterEvalQ(cl, {
  library(data.table)
  library(stringr)
  library(Rcpp)
sourceCpp("src/count_smoothing.cpp")
source("src/optimize_counts.R")
  NULL
})

# 4) run optimize_counts on each slim chunk, adding back the metadata fields
res_list <- parLapply(cl, slim_list, function(el) {
  dt  <- el$dt
  grp <- el$grp
  opt <- optimize_counts(
    dt,
    method         = "coordinate_descent",
    max_iter       = 100,
    tol            = 0.01,
    lambda_N_mono  = 1,
    lambda_D_mono  = 1,
    lambda_create  = 1
  )
  final <- opt$final
  # parse the five fields from the group name
  flds <- str_split(grp, "\\|")[[1]]
  final[, c("cellLine","experiment","plateID","ploidy","glucose") := 
          as.list(flds)]
  final
})
stopCluster(cl)

# 5) combine all results and compute hours
combined <- rbindlist(res_list, fill = TRUE)
combined[, hours := time_numeric * 24]

# 6) one faceted plot per cellLine
plots <- lapply(unique(combined$cellLine), function(cl) {
  d <- combined[cellLine == cl]
  ggplot(d, aes(x = hours)) +
    geom_point(aes(y = N-D, color = "alive")) +
    geom_point(aes(y = D, color = "dead")) +
    facet_grid(rows = vars(as.numeric(glucose)),
               cols = vars(ploidy),
               scales = "free") +
    ggtitle(cl, subtitle = unique(d$experiment))
})
names(plots) <- unique(combined$cellLine)

# Example: display the first plot
print(plots[[1]])

saveRDS(combined,"data/counts/corrected.Rds")

```




```{r}
smm <- readRDS("data/counts/uncorrected.Rds")
plots_uncorrected <- lapply(unique(smm$cellLine), function(cl) {
  d <- smm[cellLine==cl]
  ggplot(d, aes(x=hours)) +
    geom_point(aes(y=alive, color="alive")) +
    geom_point(aes(y=dead,  color="dead"))  +
    scale_y_continuous("cell count")+
    facet_grid(rows=vars(as.numeric(glucose)),
               cols=vars(ploidy),
               scales="free") +
    ggtitle(cl, subtitle=unique(d$experiment))
})
names(plots_uncorrected) <- unique(smm$cellLine)

combined <- readRDS("data/counts/corrected.Rds")
plots_corrected <- lapply(unique(combined$cellLine), function(cl) {
  d <- combined[cellLine == cl]
  ggplot(d, aes(x = hours)) +
    geom_point(aes(y = N-D, color = "alive")) +
    geom_point(aes(y = D, color = "dead")) +
    scale_y_continuous("cell count")+
    facet_grid(rows = vars(as.numeric(glucose)),
               cols = vars(ploidy),
               scales = "free") +
    ggtitle(cl, subtitle = unique(d$experiment))
})
names(plots_corrected) <- unique(combined$cellLine)



```
```{r}
source("scripts/plotSlider.R")
plot_slider_export(plots_corrected, "data/counts/corrected_plots.html")
plot_slider_export(plots_corrected, "data/counts/uncorrected_plots.html")
```


```{r}

get_matching_row <- function(row) {
  meta[cellLine == row$cellLine &
       experiment == row$experiment &
       plateID == row$plateID &
       ploidy == row$ploidy &
       glucose == row$glucose]
}

library(stringi)

match_files_from_base_keys <- function(base_keys, ff) {
  # Extract prefix and suffix using regex
  parts <- stri_match_first_regex(base_keys, "^(.*)_([^_]+_[^_]+)$")
  # parts[,2] = prefix, parts[,3] = suffix
  patterns <- paste0("^", parts[,2], "_.*_", parts[,3], "_")
  
  # Return a list of matched files per base_key
  lapply(patterns, function(pat) ff[grepl(pat, ff)])
}

split_files_by_timepoint <- function(file_list) {
  # Extract timepoint string: e.g., "00d08h00m"
  timepoints <- stri_extract_first_regex(file_list, "\\d{2}d\\d{2}h\\d{2}m")
  
  # Split into named list by unique timepoint
  split(file_list, timepoints)
}

deltaA <- abs(smm$alive-(combined$N-combined$D))
deltaD <- abs(smm$dead-combined$D)

base_keys <- get_matching_row(smm[1443,])$base_key

ims <- match_files_from_base_keys(base_keys, lookup$base)

ims <- lapply(ims, split_files_by_timepoint)


```

```{r}
source("scripts/image_utils.R")
#lookup <- make_lookup()
deltaA <- abs(smm$alive-(combined$N-combined$D))
deltaD <- abs(smm$dead-combined$D)

base_keys <- get_matching_row(smm[1443,])$base_key

time_keys <- lapply(base_keys,function(fi) unique(lookup$base[grepl(fi,lookup$base)]))



c1 <- lapply(time_keys[[1]],make_composite,lookup=lookup)
stacked <- do.call(combine,c1)

```


```{r}
library(EBImage)


make_composite_r <- function(files_by_channel) {
  # Initialize container for channels
  raw_imgs <- list(phase = list(), alive = list(), dead = list())

  # Sort into channel bins
  for (f in files_by_channel) {
    name <- tolower(strsplit(basename(f), "_")[[1]][[5]])
    img <- readImage(file.path("all_raw",f))
    if (name == "phase") {
      raw_imgs$phase[[length(raw_imgs$phase) + 1]] <- img
    } else if (grepl("alive", name)) {
      raw_imgs$alive[[length(raw_imgs$alive) + 1]] <- img
    } else if (grepl("dead", name)) {
      raw_imgs$dead[[length(raw_imgs$dead) + 1]] <- img
    }
  }

  # Max project across z-stack per channel
  proj <- lapply(raw_imgs, function(lst) {
    if (length(lst) == 0) return(NULL)
    Reduce(pmax, lst)
  })

  # Robust normalize
  robust_normalize <- function(img) {
    q <- quantile(as.numeric(img), c(0.01, 0.99), na.rm = TRUE)
    img <- (img - q[1]) / (q[2] - q[1])
    img[img < 0] <- 0
    img[img > 1] <- 1
    return(img)
  }

  proj <- lapply(proj, function(x) if (!is.null(x)) robust_normalize(x) else NULL)

  # Use phase as default base
  phase <- proj$phase
  if (is.null(phase)) {
    phase <- matrix(0, nrow = nrow(proj[[which(!sapply(proj, is.null))[1]]]), ncol = ncol(proj[[which(!sapply(proj, is.null))[1]]]))
  }

  comp <- array(0, dim = c(dim(phase), 3))

  comp[,,1] <- if (!is.null(proj$dead)) {
    pmin(phase + proj$dead, 1)
  } else {
    phase
  }

  comp[,,2] <- if (!is.null(proj$alive)) {
    pmin(phase + proj$alive, 1)
  } else {
    phase
  }

  comp[,,3] <- phase

  return(Image(comp, colormode = "Color"))
}

comp_img <- make_composite_r(ims[[1]][["00d00h00m"]])
display(comp_img)
```


