---
title: "Cell count modelling"
author: "RJB"
date: "2025-07-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/share/lab_crd/lab_crd/HighPloidy_CostBenefits/data/GlucoseStarvation/")
```

```{r}

snu668_hi <- readRDS("data/models/model_B/model_B_deoptim_SNU668_high.Rds")[[1]]$optim$bestmem
snu668_lo <- readRDS("data/models/model_B/model_B_deoptim_SNU668_low.Rds")[[1]]$optim$bestmem
sum159_lo <- readRDS("data/models/model_B/model_B_deoptim_SUM-159-chem_2N.Rds")[[1]]$optim$bestmem
sum159_hi <- readRDS("data/models/model_B/model_B_deoptim_SUM-159-chem_4N.Rds")[[1]]$optim$bestmem

npar <- length(snu668_hi)

snu668 <- data.frame(parval=c(snu668_hi,snu668_lo),parname=rep(names(snu668_hi),2),
                     ploidy=c(rep("hi",npar),rep("lo",npar)),id="SNU668")

sum159 <- data.frame(parval=c(sum159_hi,sum159_lo),parname=rep(names(sum159_hi),2),
                     ploidy=c(rep("hi",npar),rep("lo",npar)),id="sum159")

df <- rbind(snu668,sum159)

p <- ggplot(df,aes(x=parname,y=parval,color=ploidy))+
  facet_grid(rows=vars(id))+
  geom_point()+
  scale_y_log10()
p
```



```{r}
ff <- list.files("data/models/",full.names = T)

x <- lapply(ff[grepl("model_B",ff)],readRDS)

df <- data.frame(do.call(rbind,lapply(x,function(xi){
  params <- xi[[1]]$optim$bestmem
  df <- data.frame(t(params))
  id <- names(xi)
  ids <- strsplit(id,split="[.]")[[1]]
  df$cellLine <- ids[1]
  df$ploidy <- ids[2]
  df
})))

ploidy_lut <- c(parental="high",'3N'="low",high="high",low="low",'2N'="low",'4N'="high")

df$ploidy <- ploidy_lut[df$ploidy]

ci <- colnames(df)
ci <- ci[!ci%in%c("cellLine","ploidy")]
df <- split(df,f=df$cellLine)

dfn <- do.call(rbind,lapply(df,function(di){
  j <- which(di$ploidy=="low")
  for(cci in ci){
    di[,cci] <- di[,cci]/di[j,cci]
  }
  di
}))



df <- do.call(rbind,df)

df <- reshape2::melt(df,id.vars=c("ploidy","cellLine"))

p1 <- ggplot(df,aes(x=variable,y=value,color=ploidy))+
  facet_wrap(~cellLine)+
  geom_point()+
  scale_y_log10()
p1

dfn <- reshape2::melt(dfn,id.vars=c("ploidy","cellLine"))

p2 <- ggplot(dfn[dfn$ploidy=="high",],aes(x=variable,y=value,color=cellLine))+
  geom_point()+
  scale_y_log10()+
  geom_hline(yintercept=1)
p2

```



```{r}
# -----------------------------------------------------------------------------
# Comprehensive Analysis of an Intracellular Glucose Store Model
#
# This script performs a systematic analysis of a cell growth model defined
# using the 'rxode2' package. It includes:
# 1. Model Loading: Sourcing the model from an external script.
# 2. Baseline Simulation: A run with a specified set of parameters.
# 3. Parameter Scans: Exploring different dynamic regimes.
# 4. Phase Plots: Visualizing relationships between state variables.
# 5. NEW Advanced 2D Parameter Scans: Identifying key parameter trade-offs
#    across multiple metrics and environmental conditions.
# 6. NEW Phase Plot Sensitivity: Showing how trajectories change with parameters.
#
# Required Libraries:
# - rxode2: For defining and solving ODE models.
# - ggplot2: For creating high-quality plots.
# - dplyr, tidyr: For data manipulation and reshaping.
# - patchwork: For combining separate plots into a single figure.
# -----------------------------------------------------------------------------

# Step 0: Load Necessary Libraries and Model
# Ensure you have these libraries installed: install.packages(c("rxode2", "ggplot2", "dplyr", "tidyr", "patchwork"))
library(rxode2)
library(ggplot2)
library(dplyr)
library(tidyr)
library(patchwork)

# The 'intra_model' object is loaded from this script, as requested.
# Make sure the path is correct for your project structure.
# source("scripts/parameter_estimation.R") 

# For standalone execution, we define the model here. 
# If sourcing the model from the file above, this block can be ignored.
intra_model <- rxode2({
  d/dt(G) = -Vmax_uptake * (G / (Km_uptake + G)) * NL
  d/dt(NL) = (kp * (max(0,R/(NL+1e-9))^nr_g / (r_half_g^nr_g + max(0,R/(NL+1e-9))^nr_g)) - kdStarv * (r_half_d^nr_d / (r_half_d^nr_d + max(0,R/(NL+1e-9))^nr_d)) - kw * W) * NL
  d/dt(ND) = (kdStarv * (r_half_d^nr_d / (r_half_d^nr_d + max(0,R/(NL+1e-9))^nr_d)) + kw * W) * NL
  d/dt(R) = NL * Vmax_uptake * (G / (Km_uptake + G)) - NL * ((1/Y_xr) * kp * (max(0,R/(NL+1e-9))^nr_g / (r_half_g^nr_g + max(0,R/(NL+1e-9))^nr_g)) + m_r + max(0,R/(NL+1e-9)) * (kdStarv * (r_half_d^nr_d / (r_half_d^nr_d + max(0,R/(NL+1e-9))^nr_d)) + kw * W))
  d/dt(W) = (Vmax_uptake * (G / (Km_uptake + G)) - deltaW * W) * NL
})


# -----------------------------------------------------------------------------
# Step 1: Set up Baseline Simulation
# -----------------------------------------------------------------------------
# Define a clear, non-log-scale set of parameters for the simulation.
# Toxicity (kw) is set to near-zero to focus on starvation dynamics.
pars <- c(
  Vmax_uptake = 0.0001,   # mM/(#*hr)
  Km_uptake   = 0.1,      # mM
  kp          = 0.02,     # 1/hr
  Y_xr        = 500,      # #/mM
  m_r         = 1e-5,     # mM/(#*hr)
  kdStarv     = 0.08,     # 1/hr
  kw          = 1e-9,     # 1/(mM*hr) - Effectively OFF
  deltaW      = 0,        # 1/hr
  r_half_g    = 0.001,    # mM/#
  nr_g        = 4,        # unitless
  r_half_d    = 0.00002,  # mM/#
  nr_d        = 4         # unitless
)

# Define simulation time and sampling events
times <- seq(0, 200, by = 0.5) # Extended time for new analyses
ev <- eventTable() %>%
  add.sampling(times)

# Define initial conditions. Start with a reasonable internal store (R).
inits <- c(G = 1, NL = 400, ND = 0, R = 0.4, W = 0)

# Solve the model using named arguments for clarity and robustness
sol_base <- solve(intra_model, ev, params = pars, inits = inits)

# --- Plot Baseline Results ---
plot_data_base <- as.data.frame(sol_base) %>%
  pivot_longer(cols = -time, names_to = "variable", values_to = "value")

baseline_plot <- ggplot(plot_data_base, aes(x = time, y = value, color = variable)) +
  geom_line(linewidth = 1.2) +
  facet_wrap(~variable, scales = "free_y", ncol = 3) +
  labs(title = "Baseline Simulation Results (Toxicity OFF)", x = "Time (hr)", y = "Value") +
  theme_minimal() + guides(color = "none")
print(baseline_plot)


# -----------------------------------------------------------------------------
# Step 2: Systematic Parameter Scan - Varying Initial Glucose
# -----------------------------------------------------------------------------
# This scan shows how resource availability impacts population dynamics.
param_grid_g <- expand.grid(G0 = c(0.5, 1.0, 2.5, 5.0))

run_sim_g <- function(g0_val) {
  inits_g <- inits; inits_g["G"] <- g0_val
  sol <- solve(intra_model, ev, params = pars, inits = inits_g)
  as.data.frame(sol) %>% mutate(G0 = g0_val)
}

results_g <- bind_rows(lapply(param_grid_g$G0, run_sim_g))

# --- Plot Glucose Scan Results ---
plot_data_g <- results_g %>% pivot_longer(cols = -c(time, G0), names_to = "variable", values_to = "value")
glucose_scan_plot <- ggplot(plot_data_g, aes(x = time, y = value, color = factor(G0))) +
  geom_line(linewidth = 1.1) + facet_wrap(~variable, scales = "free_y", ncol = 3) +
  labs(title = "Parameter Scan: Varying Initial Glucose", color = "Initial G(0)") + theme_minimal()
print(glucose_scan_plot)


# -----------------------------------------------------------------------------
# Step 3: Phase Plot Analysis
# -----------------------------------------------------------------------------
# --- Phase Plot 1: Living Cells (NL) vs. Glucose (G) ---
phase_plot_g <- ggplot(results_g, aes(x = G, y = NL, color = factor(G0))) +
  geom_path(linewidth = 1.2, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20)) +
  labs(title = "Phase Plot: Living Cells vs. Glucose", x = "Glucose (G, mM)", y = "Living Cells (NL)", color = "Initial G(0)") +
  theme_minimal()
print(phase_plot_g)

# --- Phase Plot 2: Living Cells (NL) vs. Internal Store (R) with Thresholds ---
phase_plot_r <- ggplot(results_g, aes(x = R, y = NL, color = factor(G0))) +
  geom_path(linewidth = 1.2, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20)) +
  geom_abline(intercept = 0, slope = 1 / pars["r_half_g"], color = "darkgreen", linetype = "dashed", linewidth = 1) +
  geom_abline(intercept = 0, slope = 1 / pars["r_half_d"], color = "darkred", linetype = "dashed", linewidth = 1) +
  annotate("text", x = Inf, y = Inf, label = "Growth Threshold", hjust = 1.1, vjust = 2, color = "darkgreen", angle = 45) +
  annotate("text", x = Inf, y = Inf, label = "Death Threshold", hjust = 1.1, vjust = 15, color = "darkred", angle = 80) +
  labs(title = "Phase Plot: Living Cells vs. Internal Store", subtitle = "Trajectories shown relative to growth and death thresholds", x = "Internal Store (R, mM)", y = "Living Cells (NL)", color = "Initial G(0)") +
  theme_minimal() +
  coord_cartesian(ylim = c(0, max(results_g$NL) * 1.1))
print(phase_plot_r)


# -----------------------------------------------------------------------------
# Step 4: Advanced 2D Parameter Scans with Multiple Metrics
# -----------------------------------------------------------------------------
# This section explores key parameter trade-offs across different environmental
# conditions (initial glucose) and performance metrics.

# Define the glucose levels to test
glucose_conditions <- c(0.5, 2.0, 5.0)

# --- Scan 1: Uptake Rate (Vmax_uptake) vs. Growth Rate (kp) ---
param_grid_ug <- expand.grid(
  Vmax_uptake_val = 10^seq(-5, -3, length.out = 10),
  kp_val = seq(0.01, 0.05, length.out = 10),
  G0 = glucose_conditions
)

run_sim_multi_metric <- function(params_row) {
  run_pars <- pars
  run_pars["Vmax_uptake"] <- params_row$Vmax_uptake_val
  run_pars["kp"] <- params_row$kp_val
  run_inits <- inits; run_inits["G"] <- params_row$G0
  sol <- solve(intra_model, ev, params = run_pars, inits = run_inits)
  
  peak_NL <- max(sol$NL)
  time_to_peak <- sol$time[which.max(sol$NL)]
  integral_NL <- sum(sol$NL) * (sol$time[2] - sol$time[1])
  
  data.frame(
    Vmax_uptake = params_row$Vmax_uptake_val,
    kp = params_row$kp_val,
    G0 = params_row$G0,
    peak_NL = peak_NL,
    time_to_peak = time_to_peak,
    integral_NL = integral_NL
  )
}

results_ug_multi <- bind_rows(lapply(1:nrow(param_grid_ug), function(i) run_sim_multi_metric(param_grid_ug[i, , drop = FALSE]))) %>%
  mutate(G0_label = paste("Initial G =", G0))

# --- Plot Faceted Heatmaps for Each Metric ---
p_ug_peak <- ggplot(results_ug_multi, aes(x = Vmax_uptake, y = kp, fill = peak_NL)) +
  geom_tile() + scale_x_log10() + scale_fill_viridis_c(option = "magma") +
  facet_wrap(~G0_label) + labs(title = "Metric: Peak Population", x = "Vmax_uptake", y = "kp") + theme_minimal()

p_ug_time <- ggplot(results_ug_multi, aes(x = Vmax_uptake, y = kp, fill = time_to_peak)) +
  geom_tile() + scale_x_log10() + scale_fill_viridis_c(option = "plasma") +
  facet_wrap(~G0_label) + labs(title = "Metric: Time to Peak", x = "Vmax_uptake", y = "kp") + theme_minimal()

p_ug_integral <- ggplot(results_ug_multi, aes(x = Vmax_uptake, y = kp, fill = integral_NL)) +
  geom_tile() + scale_x_log10() + scale_fill_viridis_c(option = "cividis") +
  facet_wrap(~G0_label) + labs(title = "Metric: Population Integral", x = "Vmax_uptake", y = "kp") + theme_minimal()

print(p_ug_peak)
print(p_ug_time)
print(p_ug_integral)


# --- Scan 2: Yield (Y_xr) vs. Maintenance Cost (m_r) ---
param_grid_ym <- expand.grid(
  Y_xr_val = seq(200, 1000, length.out = 10),
  m_r_val = 10^seq(-6, -4, length.out = 10),
  G0 = glucose_conditions
)

run_sim_multi_metric_ym <- function(params_row) {
  run_pars <- pars
  run_pars["Y_xr"] <- params_row$Y_xr_val
  run_pars["m_r"] <- params_row$m_r_val
  run_inits <- inits; run_inits["G"] <- params_row$G0
  sol <- solve(intra_model, ev, params = run_pars, inits = run_inits)
  
  peak_NL <- max(sol$NL)
  time_to_peak <- sol$time[which.max(sol$NL)]
  # Corrected typo from sol_sol to sol
  integral_NL <- sum(sol$NL) * (sol$time[2] - sol$time[1])
  
  data.frame(
    Y_xr = params_row$Y_xr_val,
    m_r = params_row$m_r_val,
    G0 = params_row$G0,
    peak_NL = peak_NL,
    time_to_peak = time_to_peak,
    integral_NL = integral_NL
  )
}

results_ym_multi <- bind_rows(lapply(1:nrow(param_grid_ym), function(i) run_sim_multi_metric_ym(param_grid_ym[i, , drop = FALSE]))) %>%
  mutate(G0_label = paste("Initial G =", G0))

# --- Plot Faceted Heatmaps for Each Metric ---
p_ym_peak <- ggplot(results_ym_multi, aes(x = Y_xr, y = m_r, fill = peak_NL)) +
  geom_tile() + scale_y_log10() + scale_fill_viridis_c(option = "magma") +
  facet_wrap(~G0_label) + labs(title = "Metric: Peak Population", x = "Yield (Y_xr)", y = "Maintenance (m_r)") + theme_minimal()

p_ym_time <- ggplot(results_ym_multi, aes(x = Y_xr, y = m_r, fill = time_to_peak)) +
  geom_tile() + scale_y_log10() + scale_fill_viridis_c(option = "plasma") +
  facet_wrap(~G0_label) + labs(title = "Metric: Time to Peak", x = "Yield (Y_xr)", y = "Maintenance (m_r)") + theme_minimal()

p_ym_integral <- ggplot(results_ym_multi, aes(x = Y_xr, y = m_r, fill = integral_NL)) +
  geom_tile() + scale_y_log10() + scale_fill_viridis_c(option = "cividis") +
  facet_wrap(~G0_label) + labs(title = "Metric: Population Integral", x = "Yield (Y_xr)", y = "Maintenance (m_r)") + theme_minimal()

print(p_ym_peak)
print(p_ym_time)
print(p_ym_integral)


# -----------------------------------------------------------------------------
# Step 5: NEW - Phase Plot Sensitivity to Economic Parameters
# -----------------------------------------------------------------------------
# This analysis shows how the phase-space trajectory is altered by the trade-off
# between yield (efficiency) and maintenance cost.

param_grid_phase <- expand.grid(
  Y_xr_val = c(300, 800), # Low vs High Yield
  m_r_val = c(5e-6, 5e-5)  # Low vs High Maintenance
)

run_sim_phase <- function(params_row) {
  run_pars <- pars
  run_pars["Y_xr"] <- params_row$Y_xr_val
  run_pars["m_r"] <- params_row$m_r_val
  # Use a fixed, medium glucose level for this comparison
  run_inits <- inits; run_inits["G"] <- 2.0 
  
  sol <- solve(intra_model, ev, params = run_pars, inits = run_inits)
  
  # Create a descriptive label for the scenario
  scenario_label <- paste0(
    "Yield: ", ifelse(params_row$Y_xr_val > 500, "High", "Low"),
    ", Maint: ", ifelse(params_row$m_r_val > 1e-5, "High", "Low")
  )
  
  as.data.frame(sol) %>% mutate(scenario = scenario_label)
}

results_phase_sens <- bind_rows(lapply(1:nrow(param_grid_phase), function(i) run_sim_phase(param_grid_phase[i, , drop = FALSE])))

# --- Plot Phase Trajectories for Different Economic Strategies ---
phase_plot_sens <- ggplot(results_phase_sens, aes(x = R, y = NL, color = scenario)) +
  geom_path(linewidth = 1.2, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20)) +
  geom_abline(intercept = 0, slope = 1 / pars["r_half_g"], color = "darkgreen", linetype = "dashed", linewidth = 1) +
  geom_abline(intercept = 0, slope = 1 / pars["r_half_d"], color = "darkred", linetype = "dashed", linewidth = 1) +
  labs(
    title = "Phase Plot Sensitivity to Yield and Maintenance",
    subtitle = "Different 'economic' strategies alter the trajectory",
    x = "Internal Store (R, mM)",
    y = "Living Cells (NL)",
    color = "Strategy (Yield, Maint.)"
  ) +
  theme_minimal()

print(phase_plot_sens)

```


Results of intracellular model:

```{r}
fpath <- "data/models/"
ff <- list.files(fpath)
ff <- ff[grepl("model_intra_deopt",ff)]

x <- lapply(ff, function(fi) readRDS(file.path(fpath,fi)))
ids <- sapply(x,names)

pars <-lapply(x,function(xi) xi[[1]]$optim$bestmem)

names(pars) <- ids



```


```{r}
smm <- readRDS("data/counts/corrected.Rds")
smm$glucose <- as.numeric(smm$glucose)
smm$hours <- 24 * smm$time_numeric
smm$alive <- smm$N - smm$D
smm$dead <- smm$D

setDT(smm)
smm[, c("time_numeric", "N", "D") := NULL]


# --- 4. Split Data and Select Subset for This Job ---
groups_to_fit <- split(smm, by = c("cellLine", "ploidy"))

 ## this returns SSE 389.6!! (Deoptim output claims 94) and warnings NaNs produced!
gi <- groups_to_fit$`MDA-MB-231.3N`
pari <- pars$`MDA-MB-231.3N`
pp <- plot_model_fit(pari,gi,intra_model)

 ## this returns SSE 147!!
gi <- groups_to_fit$`MDA-MB-231.3N`
pari <- pars$`MDA-MB-231.parental` 
pp <- plot_model_fit(pari,gi,intra_model)

 ## this returns SSE 32.83 (a bit worse than DEoptim result)
gi <- groups_to_fit$`MDA-MB-231.parental`
pari <- pars$`MDA-MB-231.parental` 
pp <- plot_model_fit(pari,gi,intra_model)
```

There are a bunch of MCF10A images which don't seem to have produced valid object results. There appears to be nothing wrong with the images, so we'll need to investigate this issue further... for now filter them out for the analysis.
```{r}
source("scripts/define_plate_maps.R")
library(ggplot2)
x <- data.table::fread("data/train/labelling_output_tuned-cpsam/classification_counts.csv")
sum(x$alive<0)
x[sample(which(x$alive<0),10),]
x <- x[!x$alive<0,]

platemap_id <- sapply(x$filename,function(str){
  xi <- strsplit(str,split="_") |> unlist() 
  paste(xi[1:2],collapse="_")
}) 

print(nrow(x))

x <- x[platemap_id%in%names(m),]
print(nrow(x))

meta <- do.call(rbind,pbapply::pblapply(x$filename,get_meta))

df <- cbind(meta,x)

smm <- aggregate(list(alive=df$alive,dead=df$dead),by=list(
  cellLine=df$cellLine,
  experiment=df$experiment,
  plateID = df$plateID,
  ploidy=df$ploidy,
  glucose=df$glucose,
  hours=df$hours
),mean)
smm$glucose <- as.numeric(smm$glucose)
s <- split(smm,f=smm$cellLine)

plts <- lapply(s,function(d){
    p <- ggplot(d,aes(x=hours))+
      geom_point(aes(y=alive,color="alive"))+
      geom_point(aes(y=dead,color="dead"))+
      facet_grid(rows=vars(as.numeric(glucose)),cols=vars(ploidy),scales="free")+
      ggtitle(d$cellLine[1],subtitle = d$experiment[1])
    p
})




```

```{r}
library(rxode2)
times <- seq(0, 250, by = 0.5)

ev <- eventTable() %>%
  add.dosing(dose = 200, nbr.doses = 1, dosing.to = "NL", start.time = 0)

# 3. ADD THE SAMPLING TIMES TO THE EVENT TABLE
# This is the key step that fixes the error.
ev <- ev %>% add.sampling(times)

# 4. Solve the system
# The call now only needs the model and the event table.
solution1 <- solve(model_B, ev)

# 5. View and plot the results
head(solution1)
plot(solution1)
```


```{r}
library(parallel)
library(data.table)
library(rxode2)

# --- 1. Define all necessary objects in the main session ---

# Use the numerically stable model from our previous discussion
model <- model_B

# Create the objective function from the factory
ofun <- make_obj_fun(model)

# Define the initial parameter vector
pars <- c(model$.mv$ini, NL0 = 200, ND0 = 0)

# Your list of data subsets
data_subset <- split(smm, f = paste(smm$cellLine, smm$ploidy,smm$glucose))


# --- 2. Set up and configure the parallel cluster ---

# Start the cluster
cl <- makeCluster(getOption("cl.cores", min(60,length(data_subset))))

# Load required packages on each worker node
clusterCall(cl, fun = function() {
  library(data.table)
  library(rxode2)
})

# Export the necessary functions and variables to each worker node
clusterExport(cl, varlist = c("ofun", "pars", "model"))


# --- 3. Run the parallel computation ---

# Now the parLapply call will work because 'ofun' and 'pars' exist on the workers
opt_results <- parLapply(cl, data_subset, function(dt) {
  # It's good practice to wrap optim in try() for robustness
  optim(par = pars, fn = ofun, data_subset = dt)
})


# --- 4. Stop the cluster to release resources ---

stopCluster(cl)

# You can now inspect your results
# print(opt_results)
```


```{r}


fit_data <- create_fit_data(opt_results,data_subset,model)
fit_data <- split(fit_data,f=fit_data$cellLine)
```


```{r}
plts <- lapply(1:length(s),function(i){
  d <- s[[i]]
  fd <- fit_data[[i]]
    p <- ggplot(d,aes(x=hours))+
      geom_point(aes(y=alive,color="alive"))+
      geom_point(aes(y=dead,color="dead"))+
      geom_line(data=fd,aes(y=NL,color="alive"))+
      geom_line(data=fd,aes(y=ND,color="dead"))+
      facet_grid(rows=vars(as.numeric(glucose)),cols=vars(ploidy),scales="free")+
      ggtitle(d$cellLine[1],subtitle = d$experiment[1])
    p
})
```


```{r}
# --- 1. Setup: Load libraries and source your script ---

source("scripts/parameter_estimation.R")

fit_res <- readRDS("data/models/hsieh.Rds")

s <- split(smm,f=smm$cellLine)

for(i in 1:length(s)){
  p <- ggplot(s[[i]],aes(x=hours))+
      geom_point(aes(y=alive,color="alive"))+
      geom_point(aes(y=dead,color="dead"))+
      geom_line(data=fit_res[[i]]$traj_best,aes(y=NL,color="alive"))+
      geom_line(data=fit_res[[i]]$traj_best,aes(y=ND,color="dead"))+
      facet_grid(rows=vars(as.numeric(glucose)),cols=vars(ploidy),scales="free")+
      ggtitle(s[[i]]$cellLine[1],subtitle = s[[i]]$experiment[1])
    plot(p)
}


```

```{r}
x <- readRDS("data/models/yang_screen.Rds")
pars <- x$parameter_sets[x$summary$param_set_id[1]][[1]]


```
```{r}

library(rxode2)

intra_model <- rxode2({
  ## -----------------------------------------------------------------------
  ## Model Parameters
  ## -----------------------------------------------------------------------
  # Glucose Uptake
  Vmax_uptake <- 0.0001    # mM/(#*hr)      ; max glucose uptake rate per cell
  Km_uptake   <- 0.1       # mM              ; half-saturation for uptake

  # Growth & Maintenance from Internal Store (R)
  kp          <- 1.6e-2    # 1/hr            ; max growth rate
  Y_xr        <- 500       # #/mM            ; yield of cells from internal resource R
  m_r         <- 1e-5      # mM/(#*hr)       ; maintenance cost per cell

  # Death Rates
  kdStarv     <- 8e-2      # 1/hr            ; max death rate from starvation
  kw          <- 5e-8      # 1/(mM*hr)       ; toxicity constant for waste

  # Waste Dynamics
  deltaW      <- 0         # 1/hr            ; waste removal/decay rate

  # Growth & Death Switches (based on internal store R)
  r_half_g    <- 0.001     # mM/#            ; per-cell store R for half-maximal growth
  nr_g        <- 4         # unitless        ; hill coef for growth switch
  r_half_d    <- 0.00002   # mM/#            ; per-cell store R for half-maximal death
  nr_d        <- 4         # unitless        ; hill coef for death switch

  ## -----------------------------------------------------------------------
  ## Intermediate Calculations & Differential Equations
  ## -----------------------------------------------------------------------
  # Per-cell internal store (average)
  r_cell <- max(0,R / (NL + 1e-9))

  # Key rates
  glucose_uptake_rate <- Vmax_uptake * (G / (Km_uptake + G)) 
  growth_rate <- kp * (r_cell^nr_g / (r_half_g^nr_g + r_cell^nr_g)) 
  starvation_death_rate <- kdStarv * (r_half_d^nr_d / (r_half_d^nr_d + r_cell^nr_d)) 
  waste_death_rate <- kw * W  # SIMPLIFIED: Linear toxicity
  
  # State variables
  d/dt(G) = -glucose_uptake_rate*NL

  d/dt(NL) = (growth_rate - starvation_death_rate - waste_death_rate)*NL

  d/dt(ND) = (starvation_death_rate + waste_death_rate)*NL

  d/dt(R) = glucose_uptake_rate - NL*((1/Y_xr) * growth_rate + m_r + r_cell * (starvation_death_rate + waste_death_rate))
  
  d/dt(W) = (glucose_uptake_rate - deltaW * W)*NL # SIMPLIFIED: Waste integrates glucose use

})

times <- seq(0, 250, by = 0.5)
ev <- eventTable() %>% 
  add.sampling(times)

inits <- c(G = 1, NL = 100, ND = 0, W = 0, R = 1)
sol <- rxSolve(intra_model, ev, inits = inits)
plot(sol)

```

